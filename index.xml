<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Logs</title>
    <link>http://localhost:1313/</link>
    <description>Recent content on Logs</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Tue, 05 Jan 2016 16:31:07 +0800</lastBuildDate>
    <atom:link href="http://localhost:1313/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>clojure functional programming</title>
      <link>http://localhost:1313/blog/2016/01/05/clojure-functional-programming/</link>
      <pubDate>Tue, 05 Jan 2016 16:31:07 +0800</pubDate>
      
      <guid>http://localhost:1313/blog/2016/01/05/clojure-functional-programming/</guid>
      <description>

&lt;h1 id=&#34;clojure函数式编程:0ba14bcd112cc5275625c24eb59b1cb6&#34;&gt;Clojure函数式编程&lt;/h1&gt;

&lt;p&gt;[toc]&lt;/p&gt;

&lt;h2 id=&#34;函数:0ba14bcd112cc5275625c24eb59b1cb6&#34;&gt;函数&lt;/h2&gt;

&lt;h3 id=&#34;一等函数:0ba14bcd112cc5275625c24eb59b1cb6&#34;&gt;一等函数&lt;/h3&gt;

&lt;p&gt;函数在clj里面是一等公民;指的是函数可以被当做普通数据对待，具有以下特性：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;可以按需创建&lt;/li&gt;
&lt;li&gt;可以在数据结构中存储&lt;/li&gt;
&lt;li&gt;可以当做函数实参&lt;/li&gt;
&lt;li&gt;可以当做函数返回值&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这此特性可以为程序提供更多的灵活性.&lt;/p&gt;

&lt;h3 id=&#34;闭包:0ba14bcd112cc5275625c24eb59b1cb6&#34;&gt;闭包&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;闭包指的是函数可以访问成员变量，一般需要函数A返回一个函数B，在返回函数B里持有函数A的成员变量，形成一个闭包。&lt;/li&gt;
&lt;li&gt;也可以看做是&lt;strong&gt;函数定制&lt;/strong&gt;的一种手段&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;(defn repeat-n [n]
    (fn [num] (* n num)))

(def repeat-2 (repeat-n 2))
(repeat-2 5)  ;;=&amp;gt; 10
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;尾递归:0ba14bcd112cc5275625c24eb59b1cb6&#34;&gt;尾递归&lt;/h3&gt;

&lt;p&gt;尾递归顾名思义,是指在函数&lt;strong&gt;尾部&lt;/strong&gt;进行了递归调用. 与一般的递归区别于返回方式&amp;amp;资源释放.
一般递归需要依次返回,返回值是由首次调用函数返回的,资源需要返回后才能被释放.如递归调用函数A,A1调用A2最终返回值是由A2返回给A1,A1再返回给caller. 并且在A2执行时, A1的资源不会被释放.所以调用时要考虑递归层级问题,如果层级太深会发生堆栈溢出.
尾递归是在A2执行时,A1的资源会被释放,并且最终返回结果是由A2直接返回给caller.所以在调用时,不会出现溢出问题.
jvm并不支持尾递&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-clojure&#34;&gt;;;一般递归
(defn pow [base exp]
&amp;quot;计算base的exp次幂&amp;quot;
    (if (zero? exp)
        1
        (* base (pow base (dec exp))))
)

;;尾递归版本(clojure版本)
(defn pow (base exp)
    (letfn [(kapow [base exp sum]
            (if (zero? exp)
                sum
                (recure base (dec exp) (* base sum)))]
            (kapow base exp 1)))
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>maven.war.plugin</title>
      <link>http://localhost:1313/blog/2016/01/05/maven.war.plugin/</link>
      <pubDate>Tue, 05 Jan 2016 11:44:21 +0800</pubDate>
      
      <guid>http://localhost:1313/blog/2016/01/05/maven.war.plugin/</guid>
      <description>

&lt;h1 id=&#34;maven-war-plugin-使用说明:53af24a1bdc73cddb81b02b3b603f129&#34;&gt;maven war plugin 使用说明&lt;/h1&gt;

&lt;p&gt;[TOC]&lt;/p&gt;

&lt;h2 id=&#34;intro:53af24a1bdc73cddb81b02b3b603f129&#34;&gt;intro&lt;/h2&gt;

&lt;p&gt;主要用于处理在构建war包时的一些操作, 目前只用于对资源文件的处理.把目前使用到过的一些配置记录下来. 用以备忘.&lt;br /&gt;
直接贴一个比较完整的配置, 一看便知:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-xml&#34;&gt;&amp;lt;build&amp;gt;
    &amp;lt;plugins&amp;gt;
      &amp;lt;plugin&amp;gt;
        &amp;lt;groupId&amp;gt;org.apache.maven.plugins&amp;lt;/groupId&amp;gt;
        &amp;lt;artifactId&amp;gt;maven-war-plugin&amp;lt;/artifactId&amp;gt;
        &amp;lt;version&amp;gt;2.6&amp;lt;/version&amp;gt;
        &amp;lt;configuration&amp;gt;
		  &amp;lt;filters&amp;gt;
			&amp;lt;!-- 集中管理变量值, --&amp;gt;
            &amp;lt;filter&amp;gt;properties/config.prop&amp;lt;/filter&amp;gt;
          &amp;lt;/filters&amp;gt;
          &amp;lt;nonFilteredFileExtensions&amp;gt;
            &amp;lt;!-- default value contains jpg,jpeg,gif,bmp,png --&amp;gt;
            &amp;lt;nonFilteredFileExtension&amp;gt;conf&amp;lt;/nonFilteredFileExtension&amp;gt;
          &amp;lt;/nonFilteredFileExtensions&amp;gt;
          &amp;lt;webResources&amp;gt;
            &amp;lt;resource&amp;gt;
              &amp;lt;!-- this is relative to the pom.xml directory --&amp;gt;
              &amp;lt;directory&amp;gt;resource2&amp;lt;/directory&amp;gt;
			  &amp;lt;includes&amp;gt; &amp;lt;!-- excludes --&amp;gt;
				&amp;lt;include&amp;gt;**/*.properties&amp;lt;/include&amp;gt;
			  &amp;lt;/includes&amp;gt;
			  &amp;lt;!-- this is relative to war root dir, and it will replace all of the duplicate files --&amp;gt;
			  &amp;lt;targetPath&amp;gt;WEB-INF/classes&amp;lt;/targetPath&amp;gt;
			  &amp;lt;filtering&amp;gt;true&amp;lt;/filtering&amp;gt;
            &amp;lt;/resource&amp;gt;
          &amp;lt;/webResources&amp;gt;
        &amp;lt;/configuration&amp;gt;
      &amp;lt;/plugin&amp;gt;
    &amp;lt;/plugins&amp;gt;
&amp;lt;/build&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;资源文件处理:53af24a1bdc73cddb81b02b3b603f129&#34;&gt;资源文件处理&lt;/h2&gt;

&lt;p&gt;执行&lt;code&gt;compile&lt;/code&gt;命令的时候可以对项目的资源文件进行处理, 常用的处理有以下几种:
-   替换变量(&lt;em&gt;与profile配合使用&lt;/em&gt;)&lt;br /&gt;
在插件中的变量也是以&lt;strong&gt;&lt;code&gt;${prop.name}&lt;/code&gt;&lt;/strong&gt;方式来书写的, 如果文件内容中有相应的变量, 正好maven的ctx中又有相应的值,则会对变量进行替换.&lt;/p&gt;

&lt;h2 id=&#34;copy非标准结构目录中的文件到war指定的文件中并指定destination:53af24a1bdc73cddb81b02b3b603f129&#34;&gt;-   copy非标准结构目录中的文件到war指定的文件中并指定destination&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>about</title>
      <link>http://localhost:1313/about/</link>
      <pubDate>Tue, 05 Jan 2016 11:37:10 +0800</pubDate>
      
      <guid>http://localhost:1313/about/</guid>
      <description>

&lt;h1 id=&#34;there-is-about-md:6083a88ee3411b0d17ce02d738f69d47&#34;&gt;there is about.md&amp;hellip;&lt;/h1&gt;
</description>
    </item>
    
  </channel>
</rss>
